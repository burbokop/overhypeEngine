'use strict';

class Vector {
    constructor(...args) {
        this.coords = [];
        for(const val of args) {
            this.coords.push(val || 0);
        }
    }

    add(term) {
        const length = this.coords.length;
        const result = new Vector();
        for(let i = 0; i < length; i++) {
            if(this.coords[i] === undefined) this.coords[i] = 0;
            if(term.coords[i] === undefined) term.coords[i] = 0;
            result.coords[i] = this.coords[i] + term.coords[i];
        }
        return result;
    }
    
    subtract(subtrahend) {
        const length = this.coords.length;
        const result = new Vector();
        for(let i = 0; i < length; i++) {
            if(this.coords[i] === undefined) this.coords[i] = 0;
            if(subtrahend.coords[i] === undefined) subtrahend.coords[i] = 0;
            result.coords[i] = this.coords[i] - subtrahend.coords[i];
        }
        return result;
    }
    
    multiply(multiplier) {
        const length = this.coords.length;
        const result = new Vector();
        for(let i = 0; i < length; i++) {
            if(this.coords[i] === undefined) this.coords[i] = 0;
            if(multiplier === undefined) multiplier = 0;
            result.coords[i] = this.coords[i] * multiplier;
        }
        return result;
    }
    
    module() {
        const length = this.coords.length;
        let result = 0;
        for(let i = 0; i < length; i++) {
            result += this.coords[i] * this.coords[i];
        }
        return Math.sqrt(result);
    }

    normalized() {
        const length = this.coords.length;
        const mod = this.module();
        const result = new Vector();
        for(let i = 0; i < length; i++) {
            result.coords[i] = this.coords[i] / mod;
        }
        return result;
    }

    scalarProduct(term) {
        const length = this.coords.length;
        let result = 0;
        for(let i = 0; i < length; i++) {
            if(this.coords[i] === undefined) this.coords[i] = 0;
            if(term.coords[i] === undefined) term.coords[i] = 0;
            result += (this.coords[i] * term.coords[i]);
        }
        return result;
    }
    
    relativisticAddition(term, c) {
        if(c !== undefined ) {
            const termLength = term.module();
            if(termLength !== 0) {
                const origin = this.add(term);
                const originLength = origin.module();

                const k = Math.sqrt(1 + this.module() * termLength / (c * c));
                const u = originLength / k;

                const result = new Vector();
                const length = this.coords.length;
                for(let i = 0; i < length; i++) {
                    result.coords[i] = u * origin.coords[i] / originLength;
                }
                return result;
            }
            return this;
        }
        return this.add(term);
    }

    static createByAngle(length, angle) {
        return new Vector(length * Math.cos(angle), length * Math.sin(angle));
    }

    angle() {
        const product = this.normalized().scalarProduct(new Vector(1, 0));
        if(this.coords[1] >= 0) return Math.acos(product);
        else return -Math.acos(product);
    }

    set x(value) { this.coords[0] = value; }
    set y(value) { this.coords[1] = value; }
    set z(value) { this.coords[2] = value; }
    set t(value) { this.coords[3] = value; }

    get x() { return this.coords[0]; }
    get y() { return this.coords[1]; }
    get z() { return this.coords[2]; }
    get t() { return this.coords[3]; }
}


module.exports = Vector;

/*
double Vector::tg()
{
    if(this->y != 0) return -(this->x / this->y);
    return 0.0;
}

char Vector::quarter(char offset)
{
    if(this->y >= 0) {
        if(this->x >= 0) {
            return (0 + offset) % 4;
        }
        else {
            return (1 + offset) % 4;
        }
    }
    else {
        if(this->x >= 0) {
            return (3 + offset) % 4;
        }
        else {
            return (2 + offset) % 4;
        }
    }
}
*/
